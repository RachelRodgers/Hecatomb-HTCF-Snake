"""
Snakefile for running the Hecatomb pipeline on HTCF.

Rachel Rodgers, Sep 2020
""" 

import os
import sys
sys.path.append("./scripts")

from hecatomb_helpers import *

#----- Snakemake Set Up -----#

configfile: "config.yaml"

# Hecatomb DB paths
CONPATH = config["Paths"]["Contaminants"]
HOSTPATH = config["Paths"]["Host"]
BACPATH = config["Paths"]["Bacteria"]
AATARGET = config["Paths"]["TargetMMseqsAA"]
NTTARGET = config["Paths"]["TargetMMseqsNT"]

# Data paths
READDIR = config["Paths"]["Reads"]

# File paths
PHAGE = config["DatabaseFiles"]["Phage"]

# Java memory
XMX = config["System"]["Memory"]

# Tools
BBTOOLS = config["Tools"]["BBTools"]
R = config["Tools"]["R"]
SEQKIT = config["Tools"]["Seqkit"]
PULLSEQ = config["Tools"]["Pullseq"]
MMSEQS = config["Tools"]["MMseqs"]

#----- Rename input files if there are any to rename -----#

rename_files(config)

# Pull sample names from the renamed R1 files in /data/renamed/ and store in a list
SAMPLES, = glob_wildcards(os.path.join(READDIR, "renamed", "{sample}_R1.fastq.gz"))

PATTERN_R1 = "{sample}_R1"
PATTERN_R2 = "{sample}_R2"

#----- Snakemake Rules -----# 

#local rules: all, clean, get_r1_singletons, get_r2_singletons, concat_r1, concat_r2, extract_sequences, extract_counts, create_sequence_table

rule all:
	input:
		os.path.join("results", "mmseqs_aa_out", "phage_tax_table.tsv"),
		os.path.join("results", "mmseqs_aa_out", "viruses_seqs.fasta"),
		os.path.join("results", "mmseqs_aa_out", "pviral_aa_unclassified_seqs.fasta")

rule clean:
	shell:
		"rm -rf ./QC/ ./clumped/"
	
				
#----- Contaminant Removal -----#

# Remove non-biological sequences, low-qual bases, host and (100% ID) bacterial sequences from virome-sequencied libraries.

rule clumpify:
	"""
	Step 0: Clumpify & deduplicate reads
	"""
	input:
		r1 = os.path.join(READDIR + "/renamed/", PATTERN_R1 + ".fastq.gz"),
		r2 = os.path.join(READDIR + "/renamed/", PATTERN_R2 + ".fastq.gz")
	output:
		r1 = os.path.join("clumped", PATTERN_R1 + ".clumped.fastq.gz"),
		r2 = os.path.join("clumped", PATTERN_R2 + ".clumped.fastq.gz")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		clumpify.sh \
			in={input.r1} \
			in2={input.r2} \
			out={output.r1} \
			out2={output.r2} \
			reorder=a \
			ow=t \
			t={threads}
		""" 

rule remove_leftmost_primerB:
	"""
	Step 1: Remove leftmost primerB
	"""
	input:
		r1 = os.path.join("clumped", PATTERN_R1 + ".clumped.fastq.gz"),
		r2 = os.path.join("clumped", PATTERN_R2 + ".clumped.fastq.gz"),
		primers = os.path.join(CONPATH, "primerB.fa")
	output:
		r1 = os.path.join("QC", "step_1", PATTERN_R1 + ".s1.out.fastq"),
		r2 = os.path.join("QC", "step_1", PATTERN_R2 + ".s1.out.fastq"),
                stats = os.path.join("QC", "step_1", "{sample}.s1.stats")
	threads: 8
        shell:
                """
                module load {BBTOOLS}
                bbduk.sh \
                        in={input.r1} \
                        in2={input.r2} \
                        ref={input.primers} \
                        out={output.r1} \
                        out2={output.r2} \
                        stats={output.stats} \
                        k=16 hdist=1 mink=11 ktrim=l restrictleft=20 \
                        removeifeitherbad=f \
                        trimpolya=10 ordered=t rcomp=f ow=t \
			t={threads}
                """

rule remove_3prime_contaminant:
	"""
	Step 2: Remove 3' read-thru contaminant"
	"""
	input:
		r1 = os.path.join("QC", "step_1", PATTERN_R1 + ".s1.out.fastq"),
		r2 = os.path.join("QC", "step_1", PATTERN_R2 + ".s1.out.fastq"),
		primers = os.path.join(CONPATH, "rc_primerB_ad6.fa")
	output:
		r1 = os.path.join("QC", "step_2", PATTERN_R1 + ".s2.out.fastq"),
		r2 = os.path.join("QC", "step_2", PATTERN_R2 + ".s2.out.fastq"),
		stats = os.path.join("QC", "step_2", "{sample}.s2.stats")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbduk.sh \
			in={input.r1} \
			in2={input.r2} \
			ref={input.primers} \
			out={output.r1} \
			out2={output.r2} \
			stats={output.stats} \
			k=16 hdist=1 mink=11 ktrim=r \
			removeifeitherbad=f \
			ordered=t rcomp=f ow=t \
			threads={threads}
		"""

rule remove_primer_free_adapter:
	"""
	Step 3: Remove primer free adapter
	"""
	input:
		r1 = os.path.join("QC", "step_2", PATTERN_R1 + ".s2.out.fastq"),
		r2 = os.path.join("QC", "step_2", PATTERN_R2 + ".s2.out.fastq"),
		primers = os.path.join(CONPATH, "nebnext_adapters.fa")
	output:
		r1 = os.path.join("QC", "step_3", PATTERN_R1 + ".s3.out.fastq"),
		r2 = os.path.join("QC", "step_3", PATTERN_R2 + ".s3.out.fastq"),
		stats = os.path.join("QC", "step_3", "{sample}.s3.stats")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbduk.sh \
			in={input.r1} \
			in2={input.r2} \
			ref={input.primers} \
			out={output.r1} \
			out2={output.r2} \
			stats={output.stats} \
			k=16 hdist=1 mink=10 ktrim=r \
			removeifeitherbad=f \
			ordered=t rcomp=t ow=t \
			threads={threads}
		"""

rule remove_adapter_free_primer:
	"""
	Step 4: Remove adapter-free primer
	"""
	input:
		r1 = os.path.join("QC", "step_3", PATTERN_R1 + ".s3.out.fastq"),
		r2 = os.path.join("QC", "step_3", PATTERN_R2 + ".s3.out.fastq"),
		primers = os.path.join(CONPATH, "rc_primerB_ad6.fa")
	output:
		r1 = os.path.join("QC", "step_4", PATTERN_R1 + ".s4.out.fastq"),
		r2 = os.path.join("QC", "step_4", PATTERN_R2 + ".s4.out.fastq"),
		stats = os.path.join("QC", "step_4", "{sample}.s4.stats")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbduk.sh \
			in={input.r1} \
			in2={input.r2} \
			ref={input.primers} \
			out={output.r1} \
			out2={output.r2} \
			stats={output.stats} \
			k=16 hdist=0 \
			removeifeitherbad=f \
			ordered=t \
			rcomp=t \
			ow=t \
			t={threads}
		"""

rule remove_vector_contamination:
	"""
	Step 5: Vector contamination removal (PhiX + NCBI UniVecDB)
	"""
	input:
		r1 = os.path.join("QC", "step_4", PATTERN_R1 + ".s4.out.fastq"),
		r2 = os.path.join("QC", "step_4", PATTERN_R2 + ".s4.out.fastq"),
		primers = os.path.join(CONPATH, "vector_contaminats.fa.gz")
	output:
		r1 = os.path.join("QC", "step_5", PATTERN_R1 + ".s5.out.fastq"),
		r2 = os.path.join("QC", "step_5", PATTERN_R2 + ".s5.out.fastq"),
		stats = os.path.join("QC", "step_5", "{sample}.s5.stats")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbduk.sh \
			in={input.r1} \
			in2={input.r2} \
			ref={input.primers} \
			out={output.r1} \
			out2={output.r2} \
			stats={output.stats} \
			k=31 hammingdistance=1 ordered=t ow=t \
			t={threads}
		"""

rule host_removal:
	"""
	Step 6a: Host removal
	"""
	input:
		r1 = os.path.join("QC", "step_5", PATTERN_R1 + ".s5.out.fastq"),
		r2 = os.path.join("QC", "step_5", PATTERN_R2 + ".s5.out.fastq"),
		reference = HOSTPATH
	output:
		unmapped = os.path.join("QC", "step_6", "{sample}_unmapped.s6.out.fastq"),
		mapped = os.path.join("QC", "step_6", "{sample}_hostmapped.s6.out.fastq")
	resources:
		mem_mb=50000
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbmap.sh \
			in={input.r1} \
			in2={input.r2} \
			path={input.reference} \
			outu={output.unmapped} \
			outm={output.mapped} \
			semiperfectmode=t quickmatch fast ordered=t ow=t \
			{XMX} \
			t={threads}
		"""

rule repair:
	"""
	Step 6b: Repair the paired ends
	"""
	input:
		unmapped=os.path.join("QC", "step_6", "{sample}_unmapped.s6.out.fastq")
	output:
		r1 = os.path.join("QC", "step_6", PATTERN_R1 + ".s6.out.fastq"),
		r2 = os.path.join("QC", "step_6", PATTERN_R2 + ".s6.out.fastq")
	shell:
		"""
		module load {BBTOOLS}
		repair.sh \
			in={input.unmapped} \
			out={output.r1} \
			out2={output.r2} \
			ow=t
		"""

rule trim_low_quality:
	"""
	Step 7a: Trim low quality bases
	"""
	input:
		r1 = os.path.join("QC", "step_6", PATTERN_R1 + ".s6.out.fastq"),
		r2 = os.path.join("QC", "step_6", PATTERN_R2 + ".s6.out.fastq")
	output:
		r1 = os.path.join("QC", "step_7", PATTERN_R1 + ".s7.out.fastq"),
		r2 = os.path.join("QC", "step_7", PATTERN_R2 + ".s7.out.fastq"),
		singletons = os.path.join("QC", "step_7", "{sample}.singletons.s7.out.fastq"),
		stats = os.path.join("QC", "step_7", "{sample}.s7.stats")
	threads: 8
	shell:
		"""
		module load {BBTOOLS}
		bbduk.sh \
			in={input.r1} \
			in2={input.r2} \
			out={output.r1} \
			out2={output.r2} \
			outs={output.singletons} \
			stats={output.stats} \
			qtrim=4 trimq=20 maxns=2 minlength=50 ordered=t \
			threads={threads}
		"""
rule get_r1_singletons:
	"""
	Step 7b: Split R1 singletons
	"""
	input:
		singletons = os.path.join("QC", "step_7", "{sample}.singletons.s7.out.fastq")
	output:
		r1singletons = os.path.join("QC", "step_7", PATTERN_R1 + ".singletons.out.fastq")
	shell:
		"""
		grep -A 3 '1:N:' {input.singletons} | sed '/^--$/d' > {output.r1singletons}
		"""

rule get_r2_singletons:
	"""
	Step 7c: Split R2 singletons
	"""
	input:
		singletons = os.path.join("QC", "step_7", "{sample}.singletons.s7.out.fastq")
	output:
		r2singletons = os.path.join("QC", "step_7", PATTERN_R2 + ".singletons.out.fastq")
	shell:
		"""
		grep -A 3 '2:N:' {input.singletons} | sed '/^--$/d' > {output.r2singletons}
		"""

rule concat_r1:
	"""
	Step 7d: Concatenate R1 reads & singletons
	"""
	input:
		r1 = os.path.join("QC", "step_7", PATTERN_R1 + ".s7.out.fastq"),
		r1singletons = os.path.join("QC", "step_7", PATTERN_R1 + ".singletons.out.fastq")
	output:
		r1combo = os.path.join("QC", "step_7", PATTERN_R1 + ".s7.combined.out.fastq")
	shell:
		"""
		cat {input.r1} {input.r1singletons} > {output.r1combo} 
		"""

rule concat_r2:
	"""
	Step 7e: Concatenate R2 reads & singletons
	"""
	input:
                r2 = os.path.join("QC", "step_7", PATTERN_R2 + ".s7.out.fastq"),
                r2singletons = os.path.join("QC", "step_7", PATTERN_R2 + ".singletons.out.fastq")
	output:
		r2combo = os.path.join("QC", "step_7", PATTERN_R2 + ".s7.combined.out.fastq")
	shell:
		"""
		cat {input.r2} {input.r2singletons} > {output.r2combo}
		"""

rule remove_bacteria:
	"""
	Step 8: Remove bacterial contaminants reserving viral and ambiguous sequences
	"""
	input:
		r1combo = os.path.join("QC", "step_7", PATTERN_R1 + ".s7.combined.out.fastq"),
		reference = BACPATH 
	output:
		mapped = os.path.join("QC", "step_8", "{sample}_bacterial.fastq"),
		unmapped = os.path.join("QC", "step_8", "{sample}_viral_amb.fastq"),
		scafstats = os.path.join("QC", "step_8", "{sample}_scafstats.txt")
	threads: 16
	resources:
		 mem_mb=50000
	shell:
		"""
		module load {BBTOOLS}
		bbmap.sh \
			in={input.r1combo} \
			path={input.reference} \
			outm={output.mapped} \
			outu={output.unmapped} \
			scafstats={output.scafstats} \
			semiperfectmode=t quickmatch fast ordered=t ow=t \
			{XMX} \
			t={threads}
		"""

#----- Cluster Count -----#

# Dereplicate and count sequences

rule remove_exact_duplicates:
	"""
	Step 9: Remove exact duplicates
	"""
	input:
		os.path.join("QC", "step_8", "{sample}_viral_amb.fastq")
	output:
		os.path.join("QC", "step_9", PATTERN_R1 + ".s9.deduped.out.fastq")
	threads: 8
	resources: 
		mem_mb = 50000
	shell:
		"""
		module load {BBTOOLS}
		dedupe.sh \
			in={input} \
			out={output} \
			ow=t ac=f \
			{XMX} \
			t={threads}
		"""

rule dereplicate:
	"""
	Step 10: Dereplicate
	"""
	input:
		os.path.join("QC", "step_9", PATTERN_R1 + ".s9.deduped.out.fastq")
	output:
		fa = os.path.join("QC", "step_10", "{sample}_best.fasta"),
		stats = os.path.join("QC", "step_10", "{sample}_stats.txt")
	threads: 8
	resources:
		mem_mb = 50000
	shell:
		"""
		module load {BBTOOLS}
		dedupe.sh \
			in={input} \
			out={output.fa} \
			csf={output.stats} \
			ow=t s=4 rnc=t pbr=t \
			{XMX} \
			t={threads}
		"""

rule extract_sequence_counts:
	"""
	Step 11: Extract sequences and counts for seqtable (count table)
	"""
	input:
		os.path.join("QC", "step_10", "{sample}_best.fasta")
	output:
		out = os.path.join("QC", "step_11", "{sample}_reformatted.fasta")
	resources:
		mem_mb = 50000

	shell:
		"""
		module load {BBTOOLS}
		reformat.sh \
			in={input} \
			out={output} \
			deleteinput=t fastawrap=0 ow=t \
			{XMX}
		""" 

rule extract_sequences:
	"""
	Step 12: Extract sequence lines from sample_reformatted.fasta
	"""
	input:
		os.path.join("QC", "step_11", "{sample}_reformatted.fasta")
	output:
		os.path.join("QC", "clustered", "{sample}_seqs.txt")
	shell:
		"grep -v '>' {input} | sed '1i sequence' > {output}"

rule extract_counts:
	"""
	Step 13: Extract counts from dedupe stats file
	"""
	input:
		os.path.join("QC", "step_10", "{sample}_stats.txt")
	output:
		os.path.join("QC", "clustered", "{sample}_counts.txt")
	shell:
		"cut -f 2 {input} | sed '1s/size/{wildcards.sample}/' > {output}"

rule create_sequence_table:
	"""
	Step 14: Create sequence table
	"""
	input:
		seqs = os.path.join("QC", "clustered", "{sample}_seqs.txt"),
		counts = os.path.join("QC", "clustered", "{sample}_counts.txt")
	output:
		os.path.join("QC", "clustered", "{sample}_seqtable.txt")
	shell:
		"paste {input.seqs} {input.counts} > {output}"

rule seqtable_merge:
	"""
	Join sequence tables across all samples
	"""
	input:
		expand(os.path.join("QC", "clustered", "{sample}_seqtable.txt"), sample = SAMPLES)
	output:
		seqtable = os.path.join("results", "seqtable.all"),
		tab2fa = os.path.join("results", "seqtable.tab2fx")
	shell:
		"""
		module load {R}
		./scripts/seqtable_merge.R
		"""

#----- MMseqs2 Query Viral Seqs Against AA DB -----#

"""
Query sample sequences against Virus Uniprot DB.
Generate a phage sequence table & alignment,
non-phage virus sequence table & alignment,
and an unclassified table.
"""

rule aa_convert_seqtable_to_fasta:
	"""
	Convert seqtable.tab2fx to fasta so a sequence db can be generated from it
	"""
	input:
		os.path.join("results", "seqtable.tab2fx")
	output:
		os.path.join("results", "seqtable.fasta")
	shell:
		"""
		module load {SEQKIT}
		seqkit tab2fx {input} -o {output} -w 5000 -o {output}
		"""

rule aa_create_querydb_from_seqtable:
	"""
	Create a sequence db from the seqtable made from all samples
	"""
	input:
		os.path.join("results", "seqtable.fasta")
	output:
		os.path.join("results", "mmseqs_aa_out", "seqtable_queryDB")
	shell:
		"""
		module load {MMSEQS}
		mmseqs createdb {input} {output} --dont-shuffle 0 --dbtype 0
		"""

rule aa_taxonomy_search:
	"""
	Query the sequences in seqtable_queryDB (from the seqtable generated from all samples)
	against the virus uniprotDB to generate taxonomic assignments to the sequences using LCA.
	This is a translated search and will output an alignment.
	"""
	input:
		queryDB = os.path.join("results", "mmseqs_aa_out", "seqtable_queryDB"),
		targetDB = AATARGET
	params:
                taxaDB = os.path.join("results", "mmseqs_aa_out", "taxonomyResult")
	output:
		tmp = directory(os.path.join("results", "mmseqs_aa_out", "tmp_aa"))
	threads: 16
	shell:
		"""
		module load {MMSEQS}
		mmseqs taxonomy \
			{input.queryDB} {input.targetDB} {params.taxaDB} {output.tmp} \
			-a \
			--start-sens 1 \
			--sens-steps 3 \
			-s 7 \
			--search-type 2 \
			--tax-output-mode 1
		"""

rule aa_convert_taxonomy_result:
	"""
	Convert the alignment results DB (taxonomyResult) to a human-readable format
	"""
	input:
		queryDB = os.path.join("results", "mmseqs_aa_out", "seqtable_queryDB"),
		targetDB = AATARGET,
	params:
		alnDB = os.path.join("results", "mmseqs_aa_out", "taxonomyResult")
	output:
		os.path.join("results", "mmseqs_aa_out", "aln.m8")
	shell:
		"""
		module load {MMSEQS}
		mmseqs convertalis \
			{input.queryDB} {input.targetDB} {params.alnDB} {output} \
			--format-output "query,target,pident,alnlen,mismatch,gapopen,qstart,qend,tstart,tend,evalue,bits,qaln,taln"
		"""

rule aa_compute_lca_on_taxonomy_result:
	"""
	Compute the LCA from the taxonomyResult search
	"""
	input:
		targetDB = AATARGET
		#resultDB = os.path.join("results", "mmseqs_aa_out", "taxonomyResult")
	params:
		resultDB = os.path.join("results", "mmseqs_aa_out", "taxonomyResult"),
		taxaDB = os.path.join("results", "mmseqs-aa_out", "lcaDB")
	#output:
		#directory(os.path.join("results", "mmseqs_aa_out", "lcaDB"))
	threads: 16
	shell:
		"""
		module load {MMSEQS}
		mmseqs lca \
			{input.targetDB} {params.resultDB} {params.taxaDB} \
			--tax-lineage 1 \
			--lca-ranks "superkingdom:phylum:class:order:family:genus:species" \
			--threads {threads}
		"""

rule aa_create_taxonomy_table_from_lca:
	"""
	Create a TSV formatted taxonomy table from the LCA output
	"""
	input:
		queryDB = os.path.join("results", "mmseqs_aa_out", "seqtable_queryDB"),
		#resultDB = os.path.join("results", "mmseqs_aa_out", "lcaDB")
	params:
		resultDB = os.path.join("results", "mmseqs_aa_out", "lcaDB")
	output:
		os.path.join("results", "mmseqs_aa_out", "taxonomyResult.tsv")
	threads: 8
	shell:
		"""
		module load {MMSEQS}
		mmseqs createtsv {input.queryDB} {params.resultDB} {output} \
			--threads {threads}
		"""

rule aa_extract_all_potential_viruses:
	"""
	Extract all potential viral sequences from taxonomyResult.tsv
	"""
	input:
		os.path.join("results", "mmseqs_aa_out", "taxonomyResult.tsv")
	output:
		os.path.join("results", "mmseqs_aa_out", "all_viruses_table.tsv")
	shell:
		"""
		grep 'Viruses:' {input} | cut -f1,5 | sed 's/phi14:2/phi14_2/g' | sed 's/:/\t/g' | sort -n -k1 > {output}
		"""

rule aa_extract_phage_lineages_for_R_grep:
	"""
	Extract phage lineages from all_viruses_table.tsv and generate
	taxonomy table for import into R as a phyloseq object
	"""
	input:
		viruses = os.path.join("results", "mmseqs_aa_out", "all_viruses_table.tsv"),
		phagetax = PHAGE
	output:
		os.path.join("results", "mmseqs_aa_out", "phage_table.tsv")
	resources:
                cpus=1,
                mem_mb=1000
	shell:
		"grep -f {input.phagetax} {input.viruses} > {output}"

rule aa_extract_phage_lineages_for_R_cut:
	input:
		os.path.join("results", "mmseqs_aa_out", "phage_table.tsv")
	output:
		os.path.join("results", "mmseqs_aa_out", "phage_seqs.list")
	resources:
                cpus=1,
                mem_mb=1000
	shell:
		"cut -f1 {input} > {output}"

rule aa_extract_phage_lineages_for_R_pullseq:
	input:
		seqtable = os.path.join("results", "seqtable.fasta"),
		list = os.path.join("results", "mmseqs_aa_out", "phage_seqs.list")
	output:
		os.path.join("results", "mmseqs_aa_out", "phage_seqs.fasta")
	shell:
		"""
		module load {PULLSEQ} 
                pullseq -i {input.seqtable} -n {input.list} -l 5000 > {output}
		"""

rule aa_extract_phage_lineages_for_R_seqkit:
	input:
		os.path.join("results", "mmseqs_aa_out", "phage_seqs.fasta")
	output:
		os.path.join("results", "mmseqs_aa_out", "phage_seqs.fx2tab")
	shell:
		"""
		module load {SEQKIT}
                seqkit fx2tab {input} > {output}
		"""

rule aa_extract_phage_lineages_for_R_join:
	input:
		seqs = os.path.join("results", "mmseqs_aa_out", "phage_seqs.fx2tab"),
		table = os.path.join("results", "mmseqs_aa_out", "phage_table.tsv")
	output:
		os.path.join("results", "mmseqs_aa_out", "phage_tax_table.tsv")
	shell:
		"""
		join {input.seqs} {input.table} | \
			awk -F ' ' '{{ print $2,"\t",$3,"\t",$4,"\t",$5,"\t",$6,"\t",$7,"\t",$8,"\t",$9 }}' |
			sed '1isequence\tKingdom\tPhylum\tClass\tOrder\tFamily\tGenus\tSpecies' > {output}
	"""

rule aa_extract_nonphage_viral_lineages_for_R_grep:
	input:
		viruses = os.path.join("results", "mmseqs_aa_out", "all_viruses_table.tsv"),
		phagetax = PHAGE,
	output:
		os.path.join("results", "mmseqs_aa_out", "viruses_table.tsv")
	resources:
		cpus=1,
		mem_mb=1000
	shell:
		"grep -v -f {input.phagetax} {input.viruses} > {output}"

rule aa_extract_nonphage_viral_lineages_for_R_cut:
	input:
		os.path.join("results", "mmseqs_aa_out", "viruses_table.tsv")
	output:
		os.path.join("results", "mmseqs_aa_out", "viruses_seqs.list")
	resources:
		cpus=1,
		mem_mb=1000
	shell:
		"cut -f1 {input} > {output}"

rule aa_extract_nonphage_viral_lineages_for_R_pullseq:
	input:
		seqtable = os.path.join("results", "seqtable.fasta"),
		list = os.path.join("results", "mmseqs_aa_out", "viruses_seqs.list")
	output:
		os.path.join("results", "mmseqs_aa_out", "viruses_seqs.fasta")
	shell:
		"""
		module load {PULLSEQ}
		pullseq -i {input.seqtable} -n {input.list} -l 5000 > {output}
		"""

rule aa_extract_unclassified_grep:
	input:
		os.path.join("results", "mmseqs_aa_out", "taxonomyResult.tsv")
	output:
		os.path.join("results", "mmseqs_aa_out", "pviral_aa_unclassified_seqs.list")
	resources:
		cpus=1,
		mem_mb=1000
	shell:
		"""
		grep -v 'Viruses:' {input} | cut -f1,5 | sed 's/:/\t/g' | \
			sort -n -k1 > {output}
		"""

rule aa_extract_unclassified_pullseq:
	input:
		seqtable = os.path.join("results", "seqtable.fasta"),
		list = os.path.join("results", "mmseqs_aa_out", "pviral_aa_unclassified_seqs.list")
	output:
		os.path.join("results", "mmseqs_aa_out", "pviral_aa_unclassified_seqs.fasta")
	shell:
		"""
		module load {PULLSEQ}
		pullseq -i {input.seqtable} -n {input.list} -l 5000 > {output}
		"""

	
